{"version":3,"file":"background.js","mappings":"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","sources":["webpack://badoo-scraper-extension/./src/background/service-worker.ts","webpack://badoo-scraper-extension/webpack/startup"],"sourcesContent":["\"use strict\";\n// Background service worker for Badoo Scraper extension (MV3)\n// - receives SCRAPE_BATCH messages from content scripts\n// - deduplicates and stores profiles in chrome.storage.local\n// - supports EXPORT_CSV and CLEAR_SCRAPED messages\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst STORAGE_KEY = 'scrapedProfiles';\nfunction getStoredMap() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            chrome.storage.local.get([STORAGE_KEY], (res) => {\n                const raw = res[STORAGE_KEY] || {};\n                resolve(raw);\n            });\n        });\n    });\n}\nfunction saveStoredMap(map) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            const obj = {};\n            obj[STORAGE_KEY] = map;\n            chrome.storage.local.set(obj, () => resolve());\n        });\n    });\n}\nfunction profilesMapToArray(map) {\n    return Object.keys(map).map((k) => map[k]);\n}\nfunction toCSV(items) {\n    const header = ['id', 'url', 'name', 'age', 'location', 'photos', 'bio', 'scrapedAt'];\n    const lines = [header.join(',')];\n    for (const it of items) {\n        const row = [\n            safe(it.id),\n            safe(it.url),\n            safe(it.name),\n            it.age != null ? String(it.age) : '',\n            safe(it.location),\n            safe(it.photos ? it.photos.join(' | ') : ''),\n            safe(it.bio),\n            safe(it.scrapedAt),\n        ];\n        lines.push(row.join(','));\n    }\n    return lines.join('\\n');\n    function safe(v) {\n        if (v == null)\n            return '';\n        const s = String(v).replace(/\"/g, '\"\"');\n        if (s.includes(',') || s.includes('\\n') || s.includes('\"'))\n            return `\"${s}\"`;\n        return s;\n    }\n}\nfunction uploadBatch(uploadUrl, items, proxy) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // send items to a remote server which can forward via the provided proxy\n        // We include the proxy string in the body so the server can use it.\n        try {\n            const body = JSON.stringify({ profiles: items, proxy });\n            const res = yield fetch(uploadUrl, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body,\n            });\n            if (!res.ok) {\n                const text = yield res.text();\n                throw new Error(`Upload failed: ${res.status} ${res.statusText} - ${text}`);\n            }\n            return yield res.json().catch(() => ({}));\n        }\n        catch (err) {\n            throw err;\n        }\n    });\n}\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('Badoo Scraper: installed');\n});\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    (() => __awaiter(void 0, void 0, void 0, function* () {\n        try {\n            if (!message || !message.type)\n                return;\n            if (message.type === 'SCRAPE_BATCH') {\n                const items = message.items || [];\n                const map = yield getStoredMap();\n                let added = 0;\n                for (const p of items) {\n                    if (!p || !p.id)\n                        continue;\n                    if (!map[p.id]) {\n                        map[p.id] = p;\n                        added++;\n                    }\n                }\n                yield saveStoredMap(map);\n                sendResponse({ status: 'ok', added, total: Object.keys(map).length });\n                // If an upload URL is configured and auto-upload is enabled, attempt to upload this batch\n                try {\n                    chrome.storage.sync.get(['uploadUrl', 'autoUpload', 'proxy'], (cfg) => __awaiter(void 0, void 0, void 0, function* () {\n                        const uploadUrl = cfg && cfg.uploadUrl ? cfg.uploadUrl : null;\n                        const autoUpload = cfg && cfg.autoUpload;\n                        const proxy = cfg && cfg.proxy ? cfg.proxy : null;\n                        if (uploadUrl && autoUpload) {\n                            // send items to upload endpoint\n                            try {\n                                yield uploadBatch(uploadUrl, items, proxy);\n                                console.log('Auto-uploaded batch to', uploadUrl);\n                            }\n                            catch (err) {\n                                console.error('Auto-upload failed', err);\n                            }\n                        }\n                    }));\n                }\n                catch (err) {\n                    console.warn('Failed to check auto-upload config', err);\n                }\n            }\n            else if (message.type === 'EXPORT_CSV') {\n                const map = yield getStoredMap();\n                const arr = profilesMapToArray(map);\n                const csv = toCSV(arr);\n                // If caller asked for background download, perform it using chrome.downloads\n                if (message && message.backgroundDownload) {\n                    try {\n                        const dataUrl = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);\n                        const filename = message.filename || `badoo-scrape-${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;\n                        chrome.downloads.download({ url: dataUrl, filename }, () => {\n                            // ignore result\n                        });\n                        sendResponse({ status: 'ok', downloaded: true, count: arr.length });\n                    }\n                    catch (err) {\n                        console.error('Background download failed', err);\n                        sendResponse({ status: 'error', error: String(err) });\n                    }\n                }\n                else {\n                    sendResponse({ status: 'ok', csv, count: arr.length });\n                }\n            }\n            else if (message.type === 'CLEAR_SCRAPED') {\n                yield saveStoredMap({});\n                sendResponse({ status: 'ok', cleared: true });\n            }\n            else if (message.type === 'GET_COUNT') {\n                const map = yield getStoredMap();\n                sendResponse({ status: 'ok', count: Object.keys(map).length });\n            }\n            else if (message.type === 'GET_PROXY') {\n                chrome.storage.sync.get(['proxy'], (res) => {\n                    sendResponse({ status: 'ok', proxy: res && res.proxy ? res.proxy : null });\n                });\n                return;\n            }\n            else if (message.type === 'SAVE_PROXY') {\n                const proxy = message.proxy || null;\n                chrome.storage.sync.set({ proxy }, () => {\n                    sendResponse({ status: 'ok', saved: true });\n                });\n                return;\n            }\n            else if (message.type === 'SAVE_UPLOAD_URL') {\n                const uploadUrl = message.uploadUrl || null;\n                const autoUpload = !!message.autoUpload;\n                chrome.storage.sync.set({ uploadUrl, autoUpload }, () => {\n                    sendResponse({ status: 'ok', saved: true });\n                });\n                return;\n            }\n            else if (message.type === 'GET_UPLOAD_URL') {\n                chrome.storage.sync.get(['uploadUrl', 'autoUpload'], (res) => {\n                    sendResponse({ status: 'ok', uploadUrl: res && res.uploadUrl ? res.uploadUrl : null, autoUpload: !!(res && res.autoUpload) });\n                });\n                return;\n            }\n        }\n        catch (err) {\n            console.error('background onMessage error', err);\n            sendResponse({ status: 'error', error: String(err) });\n        }\n    }))();\n    // indicate we'll respond asynchronously\n    return true;\n});\n// Expose a simple command via chrome.commands or alarms could be added later\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[89].call(__webpack_exports__);\n"],"names":["__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","STORAGE_KEY","getStoredMap","chrome","storage","local","get","res","raw","saveStoredMap","map","obj","set","runtime","onInstalled","addListener","console","log","onMessage","message","sender","sendResponse","type","items","added","p","id","status","total","Object","keys","length","sync","cfg","uploadUrl","autoUpload","proxy","body","JSON","stringify","profiles","fetch","method","headers","ok","text","Error","statusText","json","catch","err","uploadBatch","error","warn","arr","k","csv","lines","join","it","row","safe","url","name","age","String","location","photos","bio","scrapedAt","push","v","s","replace","includes","toCSV","backgroundDownload","dataUrl","encodeURIComponent","filename","Date","toISOString","downloads","download","downloaded","count","cleared","saved","call"],"sourceRoot":""}